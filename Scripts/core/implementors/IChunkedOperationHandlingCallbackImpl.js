function IChunkedOperationHandlingCallbackImpl(){}IChunkedOperationHandlingCallbackImpl.InterfaceImpl(IChunkedOperationHandlingCallbacks,"IChunkedOperationHandlingCallbackImpl");IChunkedOperationHandlingCallbackImpl.RequiredTypes("IOperation");IChunkedOperationHandlingCallbackImpl.classInitialize=function(cls){cls.Implement(IChunkedOperation);cls.Implement(IChunkedOperationHandling);cls.prototype.$chunkroutine;cls.prototype.get_chunkroutine=function(){return this.$chunkroutine;};cls.prototype.set_chunkroutine=function(v){if(BaseObject.isCallback(v)){this.$chunkroutine=v;}else if(v==null){this.$chunkroutine=null;}else{throw"Chunk routine must be a valid callback (function, delegate, etc.) or null";}};cls.prototype.$chunks=new InitializeArray("Chunks for processing");cls.prototype.ReportOperationChunk=function(success,errorinfo_or_data){if(this.isOperationComplete()){throw"The operation is already complete. Chunks can be reported only on incomplete operation.";}this.$chunks.push({success:success,data:success?errorinfo_or_data:null,error:success?null:errorinfo_or_data});this.onOperationChunk();};cls.prototype.onOperationChunk=function(){this.$invokeChunkHandling();};cls.prototype.$invokeChunkHandling=function(){var cr=this.get_chunkroutine();if(cr!=null){var cnk;var r;while(this.$chunks.length>0){cnk=this.$chunks.shift();r=BaseObject.callCallback(cr,cnk.success,cnk.success?cnk.data:cnk.error);if(r===false){this.CompleteOperation(false,{description:"Operation forcibly rejected by chunk handler."});return;}}}};};