function IDaemonManagerImpl(){}IDaemonManagerImpl.InterfaceImpl(IDaemonManager,"IDaemonManagerImpl");IDaemonManagerImpl.classInitialize=function(cls){cls.prototype.$appmgr_lastid=0;cls.ImplementActiveIndexedProperty("activedaemons",new InitializeArray("A register for the running daemons"));cls.prototype.$instanceByName=function(name){return this.get_activedaemons().FirstOrDefault(function(idx,item){if(item.get_instancename()==name)return item;return null;});};cls.prototype.$instanceById=function(id){return this.get_activedaemons().FirstOrDefault(function(idx,item){if(item.get_instanceid()==name)return item;return null;});};cls.prototype.$instanceByClass=function(cls,noname){return this.get_activedaemons().FirstOrDefault(function(idx,item){if(BaseObject.is(item.cls)){if(noname){if(typeof item.get_instancename()=="string")return null;}return item;}return null;});}.Description("Internal. Searches for active instance of the given class by class").Param("noname","Boolean, optional - if true only among the unnamed daemons.");cls.prototype.$directClass=false;cls.prototype.$newInstanceId=function(){this.$appmgr_lastid++;return this.$appmgr_lastid;};cls.prototype.$add_activedaemon=function(name,v){if(BaseObject.is(v,"IDaemonApp")){v.set_instanceid(this.$newInstanceId());if(name!=null&&name.length>0)c.set_instancename(name);this.get_activedaemons().addElement(v);}}.Description("Internal. Adds a started daemon to the manager").Param("name","The name of the instance");cls.prototype.$removeByInstance=function(inst){this.get_activedaemons().Delete(function(idx,item){if(item==inst)return true;return null;});};cls.prototype.$startDaemon=function(name,daemonClass,startParams,single){var op=new Operation();if(typeof daemonClass!="string"){op.CompleteOperation(false,IOperation.errorname(OperationStandardErrorsEnum.parameters));return op;}var currentInst=null;if(typeof name=="string"&&name.length>0){currentInst=this.$instanceByName(name);if(BaseObject.is(currentInst,daemonClass)){op.CompleteOperation(true,currentInst.get_instanceid());return op;}else{if(currentInst!=null){op.CompleteOperation(false,IOperation.errorname(OperationStandardErrorsEnum.exists_wrongtype));}else{}}}else{currentInst=this.$instanceByClass(daemonClass,true);if(BaseObject.is(currentInst,daemonClass)&&single){op.CompleteOperation(true,currentInst.get_instanceid());return op;}}currentInst=new Function.classes[daemonClass]();if(typeof startParams=="string"){try{JBUtils.parametrize.call(currentInst,null,null,startParams);}catch(ex){op.CompleteOperation(false,IOperation.error(ex.description));}}this.$add_activedaemon(name,currentInst);currentInst.appinitialize(function(success){if(success){op.CompleteOperation(true,currentInst);currentInst.run();}else{this.$removeByInstance(currentInst);currentInst.appuninitialize(function(){jbTrace.log("After failing to initialize the daemon "+daemonClass+" finished uninitialization.");});op.CompleteOperation(false,IOperation.errorname(OperationStandardErrorsEnum.initfailed));}});return op;};cls.prototype.startDaemon=function(alias,daemonClass,parameters){var op=new Operation();var daemonItem=null;var cls=null;var prm=parameters;if(this.$directClass&&alias==null&&daemonClass!=null&&daemonClass.length>0){cls=daemonClass;}else{var reg=this.$getRegister();var dri;if(typeof alias=="string"&&alias.length>0){dri=reg.item(alias,"alias");if(dri==null){op.CompleteOperation(false,IOperation.errorname(OperationStandardErrorsEnum.notfound));return op;}cls=dri.get_daemonClass();if(prm==null)prm=dri.get_startParameters();}else if(typeof daemonClass=="string"&&daemonClass.length>0){dri=reg.item(daemonClass,"class");if(dri==null){op.CompleteOperation(false,IOperation.errorname(OperationStandardErrorsEnum.notfound));return op;}cls=dri.get_daemonClass();if(prm==null)prm=dri.get_startParameters();}else{op.CompleteOperation(false,IOperation.error("One of the both alias or daemonClass arguments must be non-empty string"));return op;}}op=this.$startDaemon(alias,cls,prm,single);return op;}.Returns("Operation").Description("Initializes the daemon and completes the operation after that. The data in the completed operation is the id of the daemon");cls.prototype.GetDaemonServiceFactory=function(daemon_id,proxybuilder){var inst=this.$instanceById(daemon_id);if(inst!=null){}throw"Not implemented";}.Returns("Returns the service factory of the specified daemon (if one is supported, if not null is returned)");cls.prototype.shutdownDaemon=function(daemon_id){throw"Not implemented";}.Returns("Operation with boolean result");cls.prototype.shutdownAllDaemons=function(){throw"Not implemented";};cls.ImplementProperty("register",new Initialize("The register to use, can be null - then the default one is used.",null));cls.prototype.$getRegister=function(){var reg=this.get_register();if(!BaseObject.is(reg,"IDaemonRegister")){if(reg==null){var dr=Registers.Default().getRegister("daemonRegister");if(BaseObject.is(dr,"IDaemonRegister")){reg=dr;}else{throw"The system daemon register is not configured. In the boot process (see $SysBoot) there must be a step where the register has to be registered with the system Registers e.g. Registers.Default().addRegsiter(new DaemonRegister()) with some daemon registrations passed to the DaemonRegister.";}}else{throw"get/set_register must be set to the instance of an IDaemonRegister or to null if the global register has to be used";}}};};