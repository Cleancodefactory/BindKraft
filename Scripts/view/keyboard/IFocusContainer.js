function IFocusContainer(){}IFocusContainer.Interface("IFocusContainer");IFocusContainer.classInitialize=function(cls){cls.Obliterator(function(){var c=this.get_focuscoordinator();if(BaseObject.is(c,"IFocusContainerRegister")){c.FCUnregisterSubordinate(this);this.set_focuscoordinator(null);}});};IFocusContainer.prototype.$hasFocus=false;IFocusContainer.ImplementProperty("focusindex",new InitializeNumericParameter("Index of the element in the focus chain",0));IFocusContainer.ImplementProperty("focuscolumn",new InitializeNumericParameter("Index of the element in the focus chain",0));IFocusContainer.ImplementProperty("focusdepth",new InitializeNumericParameter("Index of the element in the focus chain",0));IFocusContainer.ImplementProperty("focuscoordinator",new InitializeParameter("The parent of this container.",null));IFocusContainer.prototype.FCInspectChildElement=function(node){}.Description("This is called by the framework materializer to inspect a node. The container must find out if this is a focusable element, subcontainer or anything else that is controlled by it. It also needs to attach the appropriate behaviours on it.");IFocusContainer.prototype.FCEnumerate=function(){}.Description("Enumerate subcontainers or controlled elements. This is used mostly as internal function called between instances of the Interface implementations.");IFocusContainer.prototype.FCSetFocus=function(focusDirection){}.Description("Hands the focus to the container with a hint for the direction from which it comes. The container must set the actual focus to an appropriate subordinate.");IFocusContainer.prototype.OnLoseFocus=function(focusDirection){}.Description("Called by the coordinator to inform the child that the focus is about to be removed from it. Do not call this from inside or anywhere else.");IFocusContainer.prototype.FCHasFocus=function(){};IFocusContainer.prototype.FCMoveFocus=function(focusNavigation){}.Description("Moves the focus to the element in the direction specified (negative focusNavigation) or to the specified element by index (0 or positive). Note that the element index support is optional.").Param("focusNavigation","navigation instruction - specifies direction (negative) or target index (positive, optional support).").Returns("true if the navigation has been performed successfuly and false otherwise");IFocusContainer.prototype.OnChildFocusNotify=function(child,notify,direction){}.Virtual().Description("Override this to Implement focus navigation").Param("child","Child container reporting change").Param("notify","event from FocusNotifyEnum enum").Param("direction","optional direction flags from FocusDirectionEnum").Returns("true if action has been performed and false otherwise");IFocusContainer.prototype.FCNotifyCoordinator=function(notify,direction){var c=this.get_focuscoordinator();if(c!=null){return c.OnChildFocusNotify(this,notify==null?FocusNotifyEnum.surrender:notify,direction==null?FocusDirectionEnum.indeterminate:direction);}else{return false;}}.Description("Helper method calling the coordinator to perform action").Param("notify","event from FocusNotifyEnum enum. Defaults to surrender.").Param("direction","optional direction flags from FocusDirectionEnum. Defaults to indeterminate.").Returns("true if the coordinator performed an action and false otherwise. When false is returned the container should take internal action - cycle the focus or move it in another appropriate manner.");