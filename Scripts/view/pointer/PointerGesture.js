(function(){var Initialize=Class("Initialize"),InitializeBooleanParameter=Class("InitializeBooleanParameter");function PointerGesture(data){BaseObject.apply(this,arguments);this.set_data(data);}PointerGesture.Inherit(BaseObject,"PointerGesture").ImplementProperty("data",new Initialize("Any kind of user data attached to the gesture for use by the owner of the trap.",null)).ImplementProperty("recognizing",new InitializeBooleanParameter("Indicates if the gesture is still actively recognizing or stopped.",false)).ImplementProperty("initialClientPos",new Initialize("Point - initial in client viewport coords",null)).ImplementProperty("initialPagePos",new Initialize("Point - initial in page coords.",null)).ImplementProperty("trackMath",new Initialize("A track math to convert coordinates before passing them to the overrides",null));PointerGesture.prototype.$clear=function(){this.set_recognizing(false);this.clear();};PointerGesture.prototype.clear=function(){}.Description("Override to clear your spcific recognition data. No need to call this after operation, it will be called first by the start method the next time the gesture is used. Still, to release a little memory it can be called after operation.");PointerGesture.prototype.$start=function(_trackevent){this.clear();this.set_recognizing(true);var trackevent=_trackevent.cloneObject(this.get_trackMath());this.set_initialClientPos(trackevent.get_clientpos());this.set_initialPagePos(trackevent.get_pagepos());this.start(trackevent);};PointerGesture.prototype.start=function(trackevent){}.Description("Override to initialize the members your gesture needs during gesture recognition.");PointerGesture.prototype.$stop=function(){var r=this.stop();this.$clear();if(r!=null)return r;return false;}.Description("Stops the gesture - gives it a chance to uninitialize any resources it is using").Returns("Currently the return result is not used, but returning false is default (nothing running)");PointerGesture.prototype.stop=function(){return false;}.Description("Can be called by inspectEvent to cancel further recognition and directly return === false. Use like: return this.stop();");PointerGesture.prototype.$inspectEvent=function(_msg){var msg=_msg.cloneObject(this.get_trackMath());return this.inspectEvent(msg);};PointerGesture.prototype.inspectMessage=function(msg){throw"Not implemented";}.Description("All mouse events should be passed to this method after clearing the gesture before starting a new trap.").Param("msg","A PointerTrackerEvent coming from the system PointerTracker.").Returns("Empty result means the gesture recognition continues, === false means cancelled - no longer recognizing, === true gesture detected.");})();