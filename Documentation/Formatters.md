# Formatters - API

In this article the API related to formatters is described and their usage is considered only superficially - to help understanding how they work.

## Formatters, Convertors, Transformers etc. What the name(s) means.

All these names may be applicable to a formatter depending on what it does. `Formatters` is the official name, because the API uses this name in its definitions, but the same API is used for all those kinds of features and only the purpose of the specific implementation differentiates it into one of the categories - convertors, transformers, formatters and potentially some others. So, if you can't decide which one is the best - call it a formatter and be done with it. But lets see what happens in reality.

The `formatters` are designed to be used primarily through bindings - a formatter or a chain of them is configured in a binding and when the data flows from the source to the target or in the opposite direction it gets transformed by all of them in turn (we will cover the details later). Depending on why this binding exists in your markup this transformation can be something so typical like formatting a numeric, date, currency value to user readable text (back and forth), but the conversion can be something with completely different purpose - a formatter that transforms, filters, searches and reports some data from one data structure as a different structure. A simple but frequent example will be a list of (let say) comma separated string tokens in a single strings converted back and forth from/to array of strings to single string with separated tokens. Considering the example one may ask why? Well many controls or other existing constructs you want to employ in your work will have some lists of values used as some kind of parameters - can be options to select from, captions for sections, columns and what not. Having them processed and expected as arrays is probably the best way as general practice, but in real life you get them from all kinds of sources and when they have to be specified, for instance, as parameters in the HTML template markup it is obvious that comma separated string tokens will be much easier than arrays (in fact there is no syntax for arrays at this moment and it is unlikely that one will be ever needed exactly because the existence of formatters), so a formatter can convert the data to (and from) the necessary type/form and solve the problem perfectly - common practices and bringing them with converters that transform specific representations to the common ones - back and forth.

This can go quite further - for example the author once built a map component that did half of its work in formatters that transformed simple arrays with simple objects to the required by the external map types, thus giving the BindKraft app ability to use very simple generic data formats and waste no code to adapt to the requirements of the map. This is important as an illustration of an important fact about formatters:

**Formatters are legitimate place where complex data processing and preprocessing code can reside!**

_In fact this is most often the "right" way to adapt view to controller/model - dynamic conversion with caching if the processing required is too much._

## Formatters are one of the corner stones of BindKraftJS

As you may already guessed they are more important than they initially seem. Formatters are supposed to convert data in all kinds of manners while it passes from one point to another. Caching is obviously something that can be implemented if performance is a concern and this means this flow of data with conversions on the way is core principle in BindKraft. Why?

In more places than a quick look will reveal BindKRaftJS follows local `client-server` philosophy. The most obvious example is the relation between view and the code behind it. It is not the code that drives the UI - it is the view that displays data and reacts to the user interactions by advising the code (which plays a role of a controller) for them, requesting fresh data for display, asks for processing operations and consumes results. One can easily make a mess in this kind of scenarios - concurrency is a bitch. 

Trying to prepare certain data because you know it will be needed often leads to a disaster - the order things happen is not always what you expect - a UI doesn't follow a constant pattern, it follows the user, then it has to obey objective necessities - like asynchronous network requests, sidesteps involving the impact from other components/logic. This makes "`do it when asked for it`" the best way to proceed. There is no more obvious place to do this but a custom formatter that will calculate/transform/acquire what the view requests through it while supplying it and not before that. Of course one of the ways to achieve this is by implementing properties that collect, transform, calculate the requested data, but in many cases the properties are not the best way - e.g. when the data goes both ways, when you also need properties serving the same data in more raw form etc. Having a formatter that can be plugged to use these properties and additionally apply conversions, filtering or formatting is usually more flexible and generally more convenient. In the end one usually mixes the both techniques as appropriate for the specific scenario.

So, the formatters often become integral part of the app's business logic and this is not limited to view-controller interactions, in fact the modern programming almost always involves multiple semi-independent parts requesting data and services from each other. That "independency" means just that - it is a rare occasion when one such part can know how another part behaves and base its implementation on this knowledge. The only safe way is to construct the "answer" when it is asked - anything can change if you try to prepare it and make it invalid when its finally actually requested...

## How formatters are created

They are (at this point) three flavors - system, custom ad-hoc, and custom (reusable) ones. The system formatters are in the process of re-implementation and in near future they will be implemented the same way as the custom (reusable) ones, but will remains universally available as a set of system supplied formatters.